# Copyright (c) 2014 Pavel 'Blane' Tuchin
# Copyright (c) 2012 Patrice Munger
# This file is part of pynetdicom, released under a modified MIT license.
#    See the file license.txt included with this distribution, also
#    available at http://pynetdicom.googlecode.com

import threading
import tempfile
import platform
import copy
import contextlib

from itertools import izip, count
from threading import Lock


import SocketServer

from dicom.UID import ExplicitVRLittleEndian, ImplicitVRLittleEndian, \
    ExplicitVRBigEndian, UID

from dicom.filewriter import _write_file_meta_info
from dicom.filebase import DicomFileLike

import dicom.dataset

import netdicom2.sopclass as sopclass
import netdicom2.asceprovider as asceprovider
import netdicom2.exceptions


# current implementation UID. Generated by pydicom
IMPLEMENTATION_UID = '1.2.826.0.1.3680043.8.498.1.1.155105445218102811803000'
PREAMBLE = b"\0" * 128


def write_meta(fp, command_set, ts):
    fp.write(PREAMBLE)
    meta = dicom.dataset.Dataset()
    meta.MediaStorageSOPClassUID = command_set.AffectedSOPClassUID
    meta.MediaStorageSOPInstanceUID = command_set.AffectedSOPInstanceUID
    meta.TransferSyntaxUID = ts
    meta.ImplementationClassUID = IMPLEMENTATION_UID
    _write_file_meta_info(DicomFileLike(fp), meta)


class AEBase(object):
    default_ts = [ExplicitVRLittleEndian, ImplicitVRLittleEndian,
                  ExplicitVRBigEndian]

    def __init__(self, supported_ts, max_pdu_length):
        if supported_ts is None:
            supported_ts = self.default_ts

        self.supported_ts = frozenset(supported_ts)
        self.timeout = 15
        self.max_pdu_length = max_pdu_length

        self.context_def_list = {}
        self.store_in_file = set()
        self.supported_scu = {}
        self.supported_scp = {}
        self.lock = Lock()

    def add_scu(self, service):
        self.supported_scu.update({
            uid: service for uid in service.sop_classes
        })
        store_in_file = (hasattr(service, 'store_in_file') and
                         service.store_in_file)
        self.update_context_def_list(service.sop_classes, store_in_file)
        return self

    def update_context_def_list(self, sop_classes, store_in_file=False):
        start = max(self.context_def_list.keys()) if self.context_def_list \
            else 1

        self.context_def_list.update(
            self._build_context_def_list(sop_classes, start, store_in_file)
        )

    def copy_context_def_list(self):
        with self.lock:
            return copy.copy(self.context_def_list)

    @contextlib.contextmanager
    def request_association(self, remote_ae):
        """Requests association to a remote application entity"""
        assoc = None
        try:
            assoc = asceprovider.AssociationRequester(self, remote_ae=remote_ae)
            assoc.request()
            yield assoc
            if assoc.association_established:
                assoc.release()
            else:
                assoc.kill()
        except Exception:
            if assoc and assoc.association_established:
                assoc.abort()
            elif assoc:
                assoc.kill()
            raise

    def get_file(self, context, command_set):
        """Method is used by association to get file-like object to store
        dataset.

        Method is only called when service SOP Class UID is present in
        `self.store_in_file` set. Method itself does not own the file object.
        So it's service implementation responsibility to close the file after
        it's done when handling received message.
        Default implementation is based on temporary file. User may choose
        to override this method to provide a permanent storage for dataset.

        :param context: presentation context
        :param command_set: command dataset of the received message
        :return: file where association can store received dataset and file
        starting position.
        """
        tmp = tempfile.TemporaryFile()
        start = tmp.tell()
        try:
            tmp.write(PREAMBLE)
            meta = dicom.dataset.Dataset()
            meta.MediaStorageSOPClassUID = command_set.AffectedSOPClassUID
            meta.MediaStorageSOPInstanceUID = command_set.AffectedSOPInstanceUID
            meta.TransferSyntaxUID = context.supported_ts
            meta.ImplementationClassUID = IMPLEMENTATION_UID
            _write_file_meta_info(DicomFileLike(tmp), meta)
        except Exception:
            tmp.close()
            raise
        else:
            return tmp, start

    def on_association_request(self, assoc):
        """Extra processing of the association request.

        Default implementation of the method does nothing and thus accepts all
        incoming association requests.
        If association should be rejected user should override this method
        in a sub-class and raise `AssociationRejectedError` when appropriate

        :param assoc: association request parameters
        """
        pass

    def on_association_response(self, response):
        """Extra processing for association response.

        Default implementation does nothing.

        :param response: response received from remote AE
        """
        pass

    def on_receive_echo(self, context):
        """Default handling of C-ECHO command. Always returns SUCCESS code

        User should override this method in sub-class to provide custom
        handling of the command.

        :param context: presentation context (contains ID, SOP Class UID and
                        Transfer Syntax)
        :return: status that should be sent in response
        """
        return sopclass.SUCCESS

    def on_receive_store(self, context, ds):
        """Default handling of C-STORE command. Always returns
        ELEMENT_DISCARDED code.

        User should override this method in sub-class to provide custom handling
        of the command

        :param context: presentation context (contains ID, SOP Class UID and
                        Transfer Syntax)
        :param ds: dataset that should be stored
        :return: status code
        """
        return sopclass.ELEMENT_DISCARDED

    def on_receive_find(self, context, ds):
        """Default handling of C-FIND command. Returns empty iterator.

        :param context: presentation context (contains ID, SOP Class UID and
                        Transfer Syntax)
        :param ds: dataset with C-FIND parameters
        :return: iterator that returns tuples: (<result dataset>, <status code>)
        """
        return iter([])

    def on_receive_move(self, context, ds, destination):
        """Default handling of C-MOVE command. Returns empty empty values

        :param context: presentation context (contains ID, SOP Class UID and
                        Transfer Syntax)
        :param ds: dataset with C-MOVE parameters
        :param destination: C-MOVE command destination
        :return: tuple: remote AE parameters, number of operations and iterator
        that will return datasets for moving
        """
        return None, 0, iter([])

    def on_commitment_request(self, remote_ae, uids):
        """Handle storage commitment request.

        Method should return three values:
            * remote AE parameters (IP address, port, etc.)
            * iterable or None for successfully stored SOP Instance UIDs
            * iterable or None for failed SOP Instance UIDs

        Default implementation is not provided. Method raises
        `exceptions.EventHandlingError`

        :param remote_ae: remote AE title
        :param uids: iterable of tuples (SOP Class UID, SOP Instance UID)
        """
        raise netdicom2.exceptions.EventHandlingError('Not implemented')

    def on_commitment_response(self, transaction_uid, success, failure):
        """Handle storage commitment response.

        Default implementation is not provided. Method raises
        `exceptions.EventHandlingError`

        :param transaction_uid: Transaction UID
        :param success: iterable of tuples (SOP Class UID, SOP Instance UID)
        :param failure: iterable of tuples (SOP Class UID, SOP Instance UID,
                        Failure Reason
        """
        raise netdicom2.exceptions.EventHandlingError('Not implemented')

    def _build_context_def_list(self, sop_classes, start, store_in_file):
        if store_in_file:
            self.store_in_file.update(sop_classes)
        return {pc_id: asceprovider.PContextDef(pc_id, UID(sop_class),
                                                self.supported_ts)
                for sop_class, pc_id in izip(sop_classes,
                                             count(start, 2))}


class ClientAE(AEBase):
    def __init__(self, ae_title, supported_ts=None,
                 max_pdu_length=16000):
        super(ClientAE, self).__init__(supported_ts, max_pdu_length)
        self.local_ae = {'address': platform.node(), 'aet': ae_title}


class AE(AEBase, SocketServer.ThreadingTCPServer):
    """Represents a DICOM application entity

    Instance if this class represent an application entity. Once
    instantiated, it starts a new thread and enters an event loop,
    where events are association requests from remote AEs. Events
    trigger callback functions that perform user defined actions based
    on received events.
    """

    def __init__(self, ae_title, port, supported_ts=None, max_pdu_length=16000):
        SocketServer.ThreadingTCPServer.__init__(
            self,
            ('', port),
            asceprovider.AssociationAcceptor
        )
        AEBase.__init__(self, supported_ts, max_pdu_length)

        self.daemon_threads = True
        self.allow_reuse_address = True

        self.local_ae = {'address': platform.node(), 'port': port,
                         'aet': ae_title}

    def __enter__(self):
        threading.Thread(target=self.serve_forever).start()

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.quit()

    def add_scp(self, service):
        self.supported_scp.update({
            uid: service for uid in service.sop_classes
        })
        store_in_file = (hasattr(service, 'store_in_file') and
                         service.store_in_file)
        self.update_context_def_list(service.sop_classes, store_in_file)
        return self

    def quit(self):
        """Stops AE.

        This will close any open associations and will break from event loop
        for AEs that supports service SOP Classes as SCP.
        """
        self.shutdown()
        self.server_close()
